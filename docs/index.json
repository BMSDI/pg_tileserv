[
{
	"uri": "https://pramsey.github.io/pg_tileserv/introduction/",
	"title": "About pg_tileserv",
	"tags": [],
	"description": "",
	"content": "Motivation There are already lots of tile generators out there (Tegola, Geoserver, Mapserver) that read from multiple data sources and generate vector tiles. In exchange for that flexibility of format, they provide less flexibility of usage.\nBy restricting itself to only using PostGIS as a data source, pg_tileserv gains the following features:\n Automatic configuration. Just point the server at a PostgreSQL / PostGIS database, and the server can discover and automatically publish as tiles sources all tables it has read access to. Full SQL flexibility. Using function layers, the server can run any SQL at all to generate tile outputs. Any data processing or feature filtering or record aggregation you can express in SQL, you can expose as parameterized tile sources. Database security model. You can restrict access to tables and functions using standard database access control. This means you can also use advanced access control techniques, like row-level security to dynamically filter access based on the login role.  Architecture pg_tileserv is one component in \u0026ldquo;PostGIS for the Web\u0026rdquo; (aka \u0026ldquo;PostGIS FTW\u0026rdquo;), a growing family of Go spatial micro-services. Database-centric applications naturally have a central source of coordinating state, the database, which allows otherwise independent micro-services to coordinate and provide HTTP-level access to the database with relatively little middle-ware software complexity.\n pg_tileserv provides MVT tiles for interactive clients and smooth rendering pg_featureserv provides GeoJSON feature services for reading and writing vector and attribute data from tables pg_importserv (TBD) will provide an import API for ingesting arbitrary GIS data files  It should be possible to stand up a spatial services architecture of stateless microservices surrounding a PostgreSQL/PostGIS database cluster, in a standard container environment, on any cloud platform or internal datacenter: that\u0026rsquo;s \u0026ldquo;PostGIS for the Web\u0026rdquo;.\nDefinitions  Map tiles are a way of representing a multi-scale, zoomable cartographic map by regularly subidividing the plane into independent tiles that can then be rendered on a server and retrieved by a map client in parallel. Vector tiles are a specific format of map tile that encode the features as vectors and delegate rendering of the features into cartography to the client web browser. Client side vector rendering uses less bandwidth, which is good for mobile clients, and allow more options for client side dynamic data visualizations. A spatial database is a database that includes a \u0026ldquo;geometry\u0026rdquo; column type. The PostGIS extension to PostgreSQL adds a geometry column type, and hundreds of functions to operate on that type, including the ST_AsMVT() function that pg_tileserv depends upon.  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Requirements  PostgreSQL 9.5 or later PostGIS 2.4 or later  The tile server depends on the ST_AsMVT() function, which is only available if PostGIS has been compiled with support for the libprotobuf library. See the output from PostGIS_Full_Version, for example:\nSELECT postgis_full_version() POSTGIS=\u0026quot;3.0.1\u0026quot; [EXTENSION] PGSQL=\u0026quot;121\u0026quot; GEOS=\u0026quot;3.8.0-CAPI-1.13.1 \u0026quot; PROJ=\u0026quot;6.1.0\u0026quot; LIBXML=\u0026quot;2.9.4\u0026quot; LIBJSON=\u0026quot;0.13\u0026quot; LIBPROTOBUF=\u0026quot;1.3.2\u0026quot; WAGYU=\u0026quot;0.4.3 (Internal)\u0026quot; Installation To install pg_tileserv, download the binary file. Alternatively, you may run a container, or build the executable from source.\nA. Download Binaries Builds of the latest code:\n Linux Windows OSX  Unzip the file, copy the pg_tileserv binary wherever you wish, or use it in place. If you move the binary, remember to move the assets/ directory to the same location, or start the server using the AssetsDir configuration option.\nB. Run Container There is a docker image available on DockerHub.\n Docker  Run the container, provide database connection information in the DATABASE_URL environment variable and map the default service port (7800).\ndocker run -e DATABASE_URL=postgres://user:pass@host/dbname -p 7800:7800 pramsey/pg_tileserv C. Build From Source Install the Go software development environment. Make sure that the GOPATH environment variable is also set.\nSRC=$GOPATH/src/github.com/CrunchyData mkdir -p $SRC cd $SRC git clone git@github.com:CrunchyData/pg_tileserv.git cd pg_tileserv go build go install To run the build, set the DATABASE_URL environment variable to the database you want to connect to, and run the binary.\nexport DATABASE_URL=postgres://user:pass@host/dbname $GOPATH/bin/pg_tileserv Deployment Basic Operation Linux/OSX export DATABASE_URL=postgresql://username:password@host/dbname ./pg_tileserv Windows SET DATABASE_URL=postgresql://username:password@host/dbname pg_tileserv.exe Configuration File The configuration file will be automatically read from the following locations, if it exists:\n In the system configuration directory, at /etc/pg_tileserv.toml Relative to the directory from which the program is run, ./pg_tileserv.toml  If you want to pass a path directly to the configuration file, use the --config commandline parameter to pass in a pull path to configuration file. When using the --config option, configuration files in other locations will be ignored.\n./pg_tileserv --config /opt/pg_tileserv/pg_tileserv.toml In general the defaults are fine, and the program autodetects things like the server name.\n# Database connection DbConnection = \u0026#34;user=you host=localhost dbname=yourdb\u0026#34; # Close pooled connections after this interval DbPoolMaxConnLifeTime = \u0026#34;1h\u0026#34; # Hold no more than this number of connections in the database pool DbPoolMaxConns = 4 # Look to read html templates from this directory AssetsPath = \u0026#34;./assets\u0026#34; # Accept connections on this subnet (default accepts on all subnets) HttpHost = \u0026#34;0.0.0.0\u0026#34; # Accept connections on this port HttpPort = 7800 # Advertise URLs relative to this server name # default is to look this up from incoming request headers # UrlBase = \u0026#34;http://yourserver.com/\u0026#34; # Resolution to quantize vector tiles to DefaultResolution = 4096 # Rendering buffer to add to vector tiles DefaultBuffer = 256 # Limit number of features requested (-1 = no limit) MaxFeaturesPerTile = 10000 # Advertise this minimum zoom level DefaultMinZoom = 0 # Advertise this maximum zoom level DefaultMaxZoom = 22 # Output extra logging information? Debug = false "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/",
	"title": "Usage",
	"tags": [],
	"description": "",
	"content": "The purpose of pg_tileserv is to turn a set of spatial records into tiles, on the fly. The tile server reads two different layers of data:\n Table layers are what they sound like: tables in the database that have a spatial column with a spatial reference system defined on it. Function layers hide the source of data from the server, and allow the HTTP client to send in optional parameters to allow more complex SQL functionality. Any function of the form function(z integer, x integer, y integer, ...) that returns an MVT bytea result can serve as a function layer.  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "These three examples use the most common JavaScript web map components to view tiles from the tile server.\nData  Here we will link to some data for the user to load into their database  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/learn-more/",
	"title": "Learn More",
	"tags": [],
	"description": "",
	"content": "GIS  QGIS Training Manual Introduction to PostGIS Workshop PostGIS Day Talks  Web Mapping  OpenLayers Leaflet Mapbox GL JS  Source Code  GitHub  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/troubleshooting/",
	"title": "Troubleshooting",
	"tags": [],
	"description": "",
	"content": "Tile Server To get more information about what is going on behind the scenes, run the server with the --debug commandline parameter on, or turn on debugging in the configuration file:\n./pg_tileserv --debug Web Layer Hitting your service end points with a command-line utility like curl can also yield useful information:\ncurl -I http://localhost:7800/index.json Database Layer The debug mode of the tile server returns the SQL that is being called on the database, but if you want to delve more deeply into all the SQL that is being run on the database, you can turn on statement logging in PostgreSQL by editing the postgresql.conf file for your database and restarting.\nBug Reporting If you find an issue with the tile server, bugs can be reported on GitHub at the issue tracker:\n https://github.com/crunchydata/pg_tileserv/issues  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/examples/example-openlayers/",
	"title": "OpenLayers Example",
	"tags": [],
	"description": "",
	"content": "Data Web "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/metadata/",
	"title": "Service Metadata",
	"tags": [],
	"description": "",
	"content": "You can explore the contents of the tile server using:\n an HTML web interface for humans; and a JSON API for computers.  The JSON API is useful for clients that auto-configure based on the service metadata. In fact, the HTML web interface is an example of such an auto-configuring interface: it reads the JSON and uses that to set up the web map visualization and interface elements.\nWeb Interface After start-up, you can connect to the server and explore the published tables and functions in the database via a web interface at:\n http://localhost:7800  Click the \u0026ldquo;preview\u0026rdquo; link of any of the layer entries to see a web map view of the layer. The \u0026ldquo;json\u0026rdquo; link provides a direct link to the JSON metadata for that layer.\nLayers List A top-level list of layers is available in JSON at:\n http://localhost:7800/index.json  The index JSON just returns the minimum information about each layer.\n{ \u0026#34;public.ne_50m_admin_0_countries\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ne_50m_admin_0_countries\u0026#34;, \u0026#34;schema\u0026#34; : \u0026#34;public\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;table\u0026#34;, \u0026#34;id\u0026#34; : \u0026#34;public.ne_50m_admin_0_countries\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Natural Earth country data\u0026#34;, \u0026#34;detailurl\u0026#34; : \u0026#34;http://localhost:7800/public.ne_50m_admin_0_countries.json\u0026#34; } }  The detailurl provides more detailed metadata for table and function layers. The detailurl provides more detailed metadata for table and function layers. The description field is read from the comment value of the table. To set a comment on a table, use the COMMENT command. COMMENT ON TABLE ne_50m_admin_0_countries IS \u0026#39;This is my comment\u0026#39;;   "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/examples/example-mapbox-gl-js/",
	"title": "Mapbox GL JS Example",
	"tags": [],
	"description": "",
	"content": "Data Web "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/table-layers/",
	"title": "Table Layers",
	"tags": [],
	"description": "",
	"content": "By default, pg_tileserv will provide access to only those spatial tables that:\n your database connection has SELECT privileges for; include a geometry column; declare a geometry type; and, declare an SRID (spatial reference ID)  For example:\nCREATE TABLE mytable ( geom Geometry(Polygon, 4326), pid text, address text ); GRANT SELECT ON mytable TO myuser; To restrict access to a certain set of tables, use database security principles:\n Create a role with limited privileges Only grant SELECT to that role for tables you want to publish Only grant EXECUTE to that role for functions you want to publish Connect pg_tileserv to the database using that role  Table Layer Detail JSON In the detail JSON, each layer declares information relevant to setting up a map interface for the layer.\n{ \u0026#34;id\u0026#34; : \u0026#34;public.ne_50m_admin_0_countries\u0026#34;, \u0026#34;geometrytype\u0026#34; : \u0026#34;MultiPolygon\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;ne_50m_admin_0_countries\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Natural Earth countries\u0026#34;, \u0026#34;schema\u0026#34; : \u0026#34;public\u0026#34;, \u0026#34;bounds\u0026#34; : [ -180, -89.9989318847656, 180, 83.599609375 ], \u0026#34;center\u0026#34; : [ 0, -3.19966125488281 ], \u0026#34;tileurl\u0026#34; : \u0026#34;http://localhost:7800/public.ne_50m_admin_0_countries/{z}/{x}/{y}.pbf\u0026#34;, \u0026#34;properties\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;gid\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;int4\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;\u0026#34; },{ \u0026#34;name\u0026#34; : \u0026#34;featurecla\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;varchar\u0026#34; },{ \u0026#34;description\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;varchar\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;name\u0026#34; },{ \u0026#34;type\u0026#34; : \u0026#34;varchar\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;name_long\u0026#34; } ], \u0026#34;minzoom\u0026#34; : 0, \u0026#34;maxzoom\u0026#34; : 22 }  id, name and schema are the fully qualified, table and schema name of the database table. bounds and center give the extent and middle of the data collection, in geographic coordinates. The order of coordinates in bounds is [minlon, minlat, maxlon, maxlat]. The order of coordinates in center is [lon, lat]. tileurl is the standard substitution pattern URL consumed by map clients like Mapbox GL JS and OpenLayers. properties is a list of columns in the table, with their data types and descriptions. The column description field can be set using the COMMENT SQL command, for example: COMMENT ON COLUMN ne_50m_admin_0_countries.name_long IS \u0026#39;This is the long name\u0026#39;;   Table Tile Request Customization Most developers will just use the tileurl as is, but it possible to add some parameters to the URL to customize behaviour at run time:\n limit controls the number of features to write to a tile, the default is 50000. resolution controls the resolution of a tile, the default is 4096 units per side for a tile. buffer controls the size of the extra data buffer for a tile, the default is 256 units. properties is a comma-separated list of properties to include in the tile. For wide tables with large numbers of columns, this allows a slimmer tile to be composed.  For example:\nhttp://localhost:7800/public.ne_50m_admin_0_countries/{z}/{x}/{y}.pbf?limit=100000\u0026amp;properties=name,long_name  For property names that include commas (why did you do that?) URL encode the comma in the name string before composing the comma-separated string of all names.\n"
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/function-layers/",
	"title": "Function Layers",
	"tags": [],
	"description": "",
	"content": "Function Layer Detail JSON In the detail JSON, each function declares information relevant to setting up a map interface for the layer. Because functions generate tiles dynamically, the system cannot auto-discover things like extent or center. However, the custom parameters and defaults can be read from the function definition and exposed in the detail JSON.\n{ \u0026#34;name\u0026#34; : \u0026#34;parcels_in_radius\u0026#34;, \u0026#34;id\u0026#34; : \u0026#34;public.parcels_in_radius\u0026#34;, \u0026#34;schema\u0026#34; : \u0026#34;public\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Given the click point (click_lon, click_lat) and radius, returns all the parcels in the radius, clipped to the radius circle.\u0026#34;, \u0026#34;minzoom\u0026#34; : 0, \u0026#34;arguments\u0026#34; : [ { \u0026#34;default\u0026#34; : \u0026#34;-123.13\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;click_lon\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;double precision\u0026#34; }, { \u0026#34;default\u0026#34; : \u0026#34;49.25\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;click_lat\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;double precision\u0026#34; }, { \u0026#34;default\u0026#34; : \u0026#34;500.0\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;double precision\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;radius\u0026#34; } ], \u0026#34;maxzoom\u0026#34; : 22, \u0026#34;tileurl\u0026#34; : \u0026#34;http://localhost:7800/public.parcels_in_radius/{z}/{x}/{y}.pbf\u0026#34; }  description can be set using COMMENT ON FUNCTION SQL command. id, schema and name are the fully qualified name, schema and function name, respectively. minzoom and maxzoom are just the defaults, as set in the configuration file. arguments is a list of argument names, with the data type and default value.  Function Layer Examples Filtering Example This simple example returns just a filtered subset of a table (ne_50m_admin_0_countries EPSG:4326). The filter in this case is the first letters of the name. Note that the name_prefix parameter includes a default value: this is useful for clients (like the preview interface for this server) that read arbitrary function definitions and need a default value to fill into interface fields.\nCREATE OR REPLACE FUNCTION public.countries_name( z integer, x integer, y integer, name_prefix text default \u0026#39;B\u0026#39;) RETURNS bytea AS $$ WITH bounds AS ( SELECT ST_TileEnvelope(z, x, y) AS geom ), mvtgeom AS ( SELECT ST_AsMVTGeom(ST_Transform(t.geom, 3857), bounds.geom) AS geom, t.name FROM ne_50m_admin_0_countries t, bounds WHERE ST_Intersects(t.geom, ST_Transform(bounds.geom, 4326)) AND upper(t.name) LIKE (upper(name_prefix) || \u0026#39;%\u0026#39;) ) SELECT ST_AsMVT(mvtgeom, \u0026#39;public.countries_name\u0026#39;) FROM mvtgeom; $$ LANGUAGE \u0026#39;sql\u0026#39; VOLATILE PARALLEL SAFE; COMMENT ON FUNCTION public.countries_name IS \u0026#39;Filters the countries table by the initial letters of the name using the \u0026#34;name_prefix\u0026#34; parameter.\u0026#39;; Some notes about this function:\n The ST_AsMVT() function uses the function name (\u0026ldquo;public.countries_name\u0026rdquo;) as the MVT layer name. This is not required, but for clients that self-configure, it allows them to use the function name as the layer source name. In the filter portion of the query (in the WHERE clause) the bounds are transformed to the spatial reference of the table data (4326) so that the spatial index on the table geometry can be used. In the ST_AsMVTGeom() portion of the query, the table geometry is transformed into web mercator (3857) to match the bounds, and the de facto expectation that MVT tiles are delivered in web mercator projection. The ST_TileEnvelope() function used here is a utility function available in PostGIS 3.0 and higher. For earlier versions, you will probably want to add a custom function to emulate the behavior. CREATE OR REPLACE FUNCTION TS_TileEnvelope(z integer, x integer, y integer) RETURNS geometry AS $$ DECLARE size float8; zp integer = pow(2, z); gx float8; gy float8; BEGIN IF y \u0026gt;= zp OR y \u0026lt; 0 OR x \u0026gt;= zp OR x \u0026lt; 0 THEN RAISE EXCEPTION \u0026#39;invalid tile coordinate (%, %, %)\u0026#39;, z, x, y; END IF; size := 40075016.6855784 / zp; gx := (size * x) - (40075016.6855784/2); gy := (40075016.6855784/2) - (size * y); RETURN ST_SetSRID(ST_MakeEnvelope(gx, gy, gx + size, gy - size), 3857); END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39; IMMUTABLE STRICT PARALLEL SAFE;  The LIMIT is hard-coded in this example. If you want a user-defined limit, you need to add another parameter to your function definition. The function \u0026ldquo;volatility\u0026rdquo; is declared as STABLE because within one transaction context, multiple runs with the same inputs will return the same outputs. It is not marked as IMMUTABLE because changes in the base table can change the outputs over time, even for the same inputs. The function is declared as PARALLEL SAFE because it doesn\u0026rsquo;t depend on any global state that might get confused by running multiple copies of the function at once.  Spatial Processing Example This example clips a layer of parcels EPSG:26910 using a radius and center point, returning only the parcels in the radius, with the boundary parcels clipped to the center.\nCREATE OR REPLACE FUNCTION public.parcels_in_radius( z integer, x integer, y integer, click_lon float8 default -123.13, click_lat float8 default 49.25, radius float8 default 500.0) RETURNS bytea AS $$ WITH args AS ( SELECT ST_TileEnvelope(z, x, y) AS bounds, ST_Transform(ST_SetSRID(ST_MakePoint(click_lon, click_lat), 4326), 26910) AS click ), mvtgeom AS ( SELECT ST_AsMVTGeom( ST_Transform( ST_Intersection( p.geom, ST_Buffer(args.click, radius)), 3857), args.bounds) AS geom, p.site_id FROM parcels p, args WHERE ST_Intersects(p.geom, ST_Transform(args.bounds, 26910)) AND ST_DWithin(p.geom, args.click, radius) LIMIT 10000 ) SELECT ST_AsMVT(mvtgeom, \u0026#39;public.parcels_in_radius\u0026#39;) FROM mvtgeom $$ LANGUAGE \u0026#39;sql\u0026#39; STABLE PARALLEL SAFE; COMMENT ON FUNCTION public.parcels_in_radius IS \u0026#39;Given the click point (click_lon, click_lat) and radius, returns all the parcels in the radius, clipped to the radius circle.\u0026#39;; Notes:\n The parcels are stored in a table with spatial reference system 3005, a planar projection. The click parameters are longitude/latitude, so in building a click geometry (ST_MakePoint()) to use for querying, we transform the geometry to the table spatial reference. To get the parcel boundaries clipped to the radius, we build a circle in the native spatial reference (26910) using the ST_Buffer() function on the click point, then intersect that circle with the parcels.  "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/examples/example-leaflet/",
	"title": "Leaflet Example",
	"tags": [],
	"description": "",
	"content": "Data Web "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/function-layers-advanced/",
	"title": "Advanced Function Layers",
	"tags": [],
	"description": "",
	"content": "Dynamic Geometry Example So far all our examples have used simple SQL functions, but using the procedural PL/pgSQL language we can create much more interactive examples.\nCREATE OR REPLACE FUNCTION public.squares(z integer, x integer, y integer, depth integer default 2) RETURNS bytea AS $$ DECLARE result bytea; sq_width float8; tile_xmin float8; tile_ymin float8; bounds geometry; BEGIN -- Find the tile bounds  SELECT ST_TileEnvelope(z, x, y) AS geom INTO bounds; -- Find the bottom corner of the bounds  tile_xmin := ST_XMin(bounds); tile_ymin := ST_YMin(bounds); -- We want tile divided up into depth*depth squares per tile,  -- so what is the width of a square?  sq_width := (ST_XMax(bounds) - ST_XMin(bounds)) / depth; WITH mvtgeom AS ( SELECT -- Fill in the tile with all the squares  ST_AsMVTGeom(ST_MakeEnvelope( tile_xmin + sq_width * (a-1), tile_ymin + sq_width * (b-1), tile_xmin + sq_width * a, tile_ymin + sq_width * b), bounds), -- Each square gets a property that shows  -- what tile it is a part of and what its sub-address  -- in that tile is  Format(\u0026#39;(%s.%s,%s.%s)\u0026#39;, x, a, y, b) AS tilecoord -- Drive the square generator with a two-dimensional  -- generate_series setup  FROM generate_series(1, depth) a, generate_series(1, depth) b ) SELECT ST_AsMVT(mvtgeom.*, \u0026#39;public.squares\u0026#39;) -- Put the query result into the result variale.  INTO result FROM mvtgeom; -- Return the answer  RETURN result; END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39; IMMUTABLE -- Same inputs always give same outputs STRICT -- Null input gets null output PARALLEL SAFE; COMMENT ON FUNCTION public.squares IS \u0026#39;For each tile requested, generate and return depth*depth polygons covering the tile. The effect is one of always having a grid coverage at the appropriate current scale.\u0026#39;; Dynamic Hexagons with Spatial Join Example Hexagonal tilings are popular with data visualization experts because they can be used to summarize point data without adding a visual bias to the output via different summary area sizes. They also have a nice \u0026ldquo;non-pointy\u0026rdquo; shape, while still providing a complete tiling of the plane.\nWhen you want to provide a hexagonal summary of a data set at multiple scales, you have an implementation problem: do you need to create a pile of hexagon tables, solely for the purpose of summary visualization?\nNo, you don\u0026rsquo;t have to, you can generate your hexagons dynamically based on the scale of the requested map tiles.\nThe first challenge is that a hexagon tile set cannot be perfectly inscribed into a powers-of-two square tile set. That means that any given tile will contain some odd combination of full and partial hexagons. In order for the hexagons that straddle tile boundaries to match up, we need a hexagon tiling that is uniform over the whole plane.\nSo, our first function takes a \u0026ldquo;hexagon grid coordinate\u0026rdquo; and generates a hexagon for that coordinate. The size and location of that hexagon are controlled by the hexagon edge length for this particular tiling.\n-- Given coordinates in the hexagon tiling that has this -- edge size, return the built-out hexagon CREATE OR REPLACE FUNCTION hexagon(i integer, j integer, edge float8) RETURNS geometry AS $$ DECLARE h float8 := edge*cos(pi()/6.0); cx float8 := 1.5*i*edge; cy float8 := h*(2*j+abs(i%2)); BEGIN RETURN ST_MakePolygon(ST_MakeLine(ARRAY[ ST_MakePoint(cx - 1.0*edge, cy + 0), ST_MakePoint(cx - 0.5*edge, cy + -1*h), ST_MakePoint(cx + 0.5*edge, cy + -1*h), ST_MakePoint(cx + 1.0*edge, cy + 0), ST_MakePoint(cx + 0.5*edge, cy + h), ST_MakePoint(cx - 0.5*edge, cy + h), ST_MakePoint(cx - 1.0*edge, cy + 0) ])); END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39; IMMUTABLE STRICT PARALLEL SAFE; SELECT ST_AsText(hexagon(2, 2, 10.0));  POLYGON((20 34.6410161513775,25 25.9807621135332, 35 25.9807621135332,40 34.6410161513775, 35 43.3012701892219,25 43.3012701892219, 20 34.6410161513775)) Now we need a function that, given a square input (a map tile), can figure out all the hexagon coordinates that fall within the tile. Again, the edge size of the hexagon tiling determines the overall geometry of the hex tiling. More than one hexagon will be required most times, so this is a set-returning function.\n-- Given a square bounds, find all the hexagonal cells -- of a hex tiling (determined by edge size) -- that might cover that square (slightly over-determined) CREATE OR REPLACE FUNCTION hexagoncoordinates(bounds geometry, edge float8, OUT i integer, OUT j integer) RETURNS SETOF record AS $$ DECLARE h float8 := edge*cos(pi()/6); mini integer := floor(st_xmin(bounds) / (1.5*edge)); minj integer := floor(st_ymin(bounds) / (2*h)); maxi integer := ceil(st_xmax(bounds) / (1.5*edge)); maxj integer := ceil(st_ymax(bounds) / (2*h)); BEGIN FOR i, j IN SELECT a, b FROM generate_series(mini, maxi) a, generate_series(minj, maxj) b LOOP RETURN NEXT; END LOOP; END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39; IMMUTABLE STRICT PARALLEL SAFE; SELECT * FROM hexagoncoordinates(ST_TileEnvelope(15, 1, 1), 1000.0);  i | j --------+------- -13358 | 11567 -13358 | 11568 -13357 | 11567 -13357 | 11568 -13356 | 11567 -13356 | 11568 Next, we need a function that puts the two parts together: with tile coordinates and edge size as input, generate the set of all the hexagons that cover the tile. The output here is basically a spatial table\u0026ndash;a set of rows, each row containing a geometry (hexagon) and some properties (hexagon coordinates). This is the input we need for a spatial join.\n-- Given an input ZXY tile coordinate, output a set of hexagons -- (and hexagon coordinates) in web mercator that cover that tile CREATE OR REPLACE FUNCTION tilehexagons(z integer, x integer, y integer, step integer, OUT geom geometry(Polygon, 3857), OUT i integer, OUT j integer) RETURNS SETOF record AS $$ DECLARE bounds geometry; maxbounds geometry := ST_TileEnvelope(0, 0, 0); edge float8; BEGIN bounds := ST_TileEnvelope(z, x, y); edge := (ST_XMax(bounds) - ST_XMin(bounds)) / pow(2, step); FOR geom, i, j IN SELECT ST_SetSRID(hexagon(h.i, h.j, edge), 3857), h.i, h.j FROM hexagoncoordinates(bounds, edge) h LOOP IF maxbounds ~ geom AND bounds \u0026amp;\u0026amp; geom THEN RETURN NEXT; END IF; END LOOP; END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39; IMMUTABLE STRICT PARALLEL SAFE; The function that the tile server actually calls looks like all other tile server functions: tile coordinates and optional parameter as input, bytea MVT as output.\n-- Given an input tile, generate the covering hexagons, -- spatially join to population table, summarize -- population in each hexagon, and generate MVT -- output of the result. Step parameter determines -- how many hexagons to generate per tile. CREATE OR REPLACE FUNCTION public.hexpopulationsummary(z integer, x integer, y integer, step integer default 4) RETURNS bytea AS $$ WITH bounds AS ( -- Convert tile coordinates to web mercator tile bounds  SELECT ST_TileEnvelope(z, x, y) AS geom ), rows AS ( -- Summary of populated places grouped by hex  SELECT Sum(pop_max) AS pop_max, Sum(pop_min) AS pop_min, h.i, h.j, h.geom -- All the hexes that interact with this tile  FROM TileHexagons(z, x, y, step) h -- All the populated places  JOIN ne_50m_populated_places n -- Transform the hex into the SRS (4326 in this case)  -- of the table of interest  ON ST_Intersects(n.geom, ST_Transform(h.geom, 4326)) GROUP BY h.i, h.j, h.geom ), mvt AS ( -- Usual tile processing, ST_AsMVTGeom simplifies, quantizes,  -- and clips to tile boundary  SELECT ST_AsMVTGeom(rows.geom, bounds.geom) AS geom, rows.pop_max, rows.pop_min, rows.i, rows.j FROM rows, bounds ) -- Generate MVT encoding of final input record SELECT ST_AsMVT(mvt, \u0026#39;public.hexpopulationsummary\u0026#39;) FROM mvt $$ LANGUAGE \u0026#39;sql\u0026#39; STABLE STRICT PARALLEL SAFE; COMMENT ON FUNCTION public.hexpopulationsummary IS \u0026#39;Hex summary of the ne_50m_populated_places table. Step parameter determines how approximately many hexes (2^step) to generate per tile.\u0026#39;; "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/usage/security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": "The basic principle of security is to connect your tile server to the database with a user that has just the access you want it to have, and no more. To support different access patterns, create different users with access to different tables/functions, and run multiple services, connecting with those different users.\nCREATE USER tileserver; Start with a blank user. A blank user will have no select privileges on tables it does not own. It will have execute privileges on functions. However, the user will have no select privileges on tables accessed by functions, so effectively the user will still have no access to data.\nTables If your tables are in a schema other than public, you will have to also grant \u0026ldquo;usage\u0026rdquo; on that schema to your user.\nGRANT USAGE ON SCHEMA myschema TO tileserver; You can then grant access to the user one table at a time.\nGRANT SELECT ON TABLE myschema.mytable TO tileserver; Alternatively, you can grant access to all the tables at once.\nGRANT SELECT ON ALL TABLES IN SCHEMA myschema TO tileserver; Functions As noted above, functions that access table data effectively are restricted by the access levels the user has to the tables the function reads. If you want to completely restrict access to the function, including visibility in the user interface, you can strip execution privileges from the function.\n-- All functions grant execute to \u0026#39;public\u0026#39; and all roles are -- part of the \u0026#39;public\u0026#39; group, so public has to be removed -- from the executors of the function REVOKE EXECUTE ON FUNCTION myschema.myfunction FROM public; -- Just to be sure, also revoke execute from the user REVOKE EXECUTE ON FUNCTION myschema.myfunction FROM tileserver; "
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/readme/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Content Organization The content folder is a collection of Markdown files placed in different subfolders (plus a top-level _index.md file). When the site renders, these subfolders will display as top-level sections accessible in the navigation.\n_index.md is for the guide\u0026rsquo;s homepage.\nA section (subfolder) may also contain multiple subtopics. For example, the Installation section has three subtopics: Requirements (05-requirements.md), Installation (06-installation.md), and Deployment (07-deployment.md). On the other hand, the Learn More section does not have any subtopics, so it contains only one file (the index file). Each subfolder must have its own index file.\nAdding Content Each .md file will start with a snippet that looks like this:\n--- title: \u0026quot;Page Title\u0026quot; date: draft: false weight: 10 --- title corresponds to the title of the page, or section if it is an index file within a subfolder. date is optional. draft indicates the draft status: set to true if you don\u0026rsquo;t want Hugo to publish the page.\nweight determines the section and page order. Each section is ordered based on their respective index files. Use double digits (e.g. weight: 10) to order the top level sections. The subtopics are ordered based on the individual Markdown files. Use more digits (e.g. weight: 150) for ordering subtopics.\nYou should feel free to remove or add new files or subfolders/sections as you see fit.\nIf you would like to add a new file (i.e. a separate page), make sure to follow the file naming convention:\n prefixed with a digit to help you keep track of the order (e.g. 09-) dashes instead of spaces use the .md extension  If necessary, change the number prefixes of the other files to apply a change in order.\n"
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/",
	"title": "pg_tileserv",
	"tags": [],
	"description": "",
	"content": "pg_tileserv pg_tileserv is a PostGIS-only tile server in Go. Strip away all the other requirements, it just has to take in HTTP tile requests and form and execute SQL. In a sincere act of flattery, the API and design look a lot like that of the Martin tile server.\nThis guide will walk you through how to install and use pg_tileserv for your spatial applications. The Usage section goes in-depth on how the service works. We also include some basic examples of web maps that render tiles from pg_tileserv.\n"
},
{
	"uri": "https://pramsey.github.io/pg_tileserv/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]